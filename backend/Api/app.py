from fastapi import FastAPI, UploadFile, File, HTTPException
from fastapi.responses import JSONResponse
from transformers import pipeline
import io
import fitz  # PyMuPDF
import os
import tempfile

# Charger le mod√®le de r√©sum√©
summarizer = pipeline("summarization", model="facebook/bart-large-cnn")

# Configuration de l'API avec m√©tadonn√©es
app = FastAPI(
    title="üìÑ API de R√©sum√© de PDF",
    description="""
    ## üöÄ API de r√©sum√© automatique de documents PDF
    
    Cette API utilise l'intelligence artificielle pour g√©n√©rer des r√©sum√©s automatiques 
    de vos documents PDF en fran√ßais.
    
    ### ‚ú® Fonctionnalit√©s principales :
    
    * **Extraction de texte** : Extraction automatique du contenu textuel des PDF
    * **R√©sum√© intelligent** : Utilisation du mod√®le BART de Facebook pour g√©n√©rer des r√©sum√©s de qualit√©
    * **Gestion des longs documents** : Division automatique des textes longs en segments pour un traitement optimal
    * **Robustesse** : Gestion d'erreurs avanc√©e et r√©cup√©ration automatique
    * **S√©curit√©** : Nettoyage automatique des fichiers temporaires
    
    ### üîß Mod√®le utilis√© :
    
    **facebook/bart-large-cnn** - Mod√®le de r√©sum√© extractif/abstractif pr√©-entra√Æn√©
    
    ### üìä Limitations :
    
    * Fichiers PDF uniquement
    * Taille recommand√©e : < 10 MB
    * Langues support√©es : Principalement anglais et fran√ßais
    * Format de sortie : R√©sum√© en texte simple
    """,
    version="1.0.0",
    terms_of_service="https://example.com/terms/",
    contact={
        "name": "Support API",
        "email": "support@example.com",
    },
    license_info={
        "name": "MIT License",
        "url": "https://opensource.org/licenses/MIT",
    },
)

def split_text_into_chunks(text, max_length=500):
    """
    Divise le texte en chunks plus petits pour √©viter de d√©passer la limite du mod√®le.
    
    Args:
        text (str): Le texte √† diviser
        max_length (int): Nombre maximum de mots par chunk (d√©faut: 500)
    
    Returns:
        list: Liste des chunks de texte
    """
    words = text.split()
    chunks = []
    current_chunk = []
    current_length = 0
    
    for word in words:
        if current_length + len(word) + 1 <= max_length:
            current_chunk.append(word)
            current_length += len(word) + 1
        else:
            if current_chunk:
                chunks.append(' '.join(current_chunk))
            current_chunk = [word]
            current_length = len(word)
    
    if current_chunk:
        chunks.append(' '.join(current_chunk))
    
    return chunks

def summarize_long_text(text):
    """
    R√©sume un texte long en le divisant en chunks si n√©cessaire.
    
    Strat√©gie de r√©sum√© :
    1. Textes courts (‚â§500 mots) : R√©sum√© direct
    2. Textes longs : Division en chunks de 500 mots ‚Üí r√©sum√© de chaque chunk ‚Üí fusion
    3. En cas d'erreur : Re-division en chunks plus petits (300 mots)
    
    Args:
        text (str): Le texte √† r√©sumer
    
    Returns:
        str: Le r√©sum√© du texte ou un message d'erreur
    """
    # Si le texte est court, le r√©sumer directement
    if len(text.split()) <= 500:
        try:
            summary = summarizer(text, max_length=130, min_length=30, do_sample=False)
            return summary[0]['summary_text']
        except Exception as e:
            return f"Erreur lors du r√©sum√©: {str(e)}"
    
    # Si le texte est long, le diviser en chunks
    chunks = split_text_into_chunks(text, max_length=500)
    summaries = []
    
    for i, chunk in enumerate(chunks):
        try:
            # Utiliser des param√®tres plus conservateurs
            summary = summarizer(chunk, max_length=80, min_length=20, do_sample=False)
            summaries.append(summary[0]['summary_text'])
        except Exception as e:
            # En cas d'erreur, essayer avec un chunk encore plus petit
            try:
                smaller_chunks = split_text_into_chunks(chunk, max_length=300)
                for small_chunk in smaller_chunks:
                    small_summary = summarizer(small_chunk, max_length=50, min_length=15, do_sample=False)
                    summaries.append(small_summary[0]['summary_text'])
            except Exception as e2:
                summaries.append(f"Segment {i+1} trop complexe √† r√©sumer.")
    
    # Combiner tous les r√©sum√©s
    combined_summary = ' '.join(summaries)
    
    # Si le r√©sum√© combin√© est encore trop long, le r√©sumer √† nouveau
    if len(combined_summary.split()) > 500:
        try:
            final_summary = summarizer(combined_summary, max_length=130, min_length=30, do_sample=False)
            return final_summary[0]['summary_text']
        except Exception as e:
            return combined_summary  # Retourner le r√©sum√© combin√© si √©chec
    
    return combined_summary

def extract_text_from_pdf(pdf_file):
    """
    Extrait le contenu textuel d'un fichier PDF.
    
    Args:
        pdf_file (str): Chemin vers le fichier PDF
    
    Returns:
        str: Texte extrait du PDF
    """
    with fitz.open(pdf_file) as doc:
        text = ""
        for page in doc:
            text += page.get_text("text")
    return text

@app.post(
    "/summarize_pdf/",
    summary="üìÑ R√©sumer un document PDF",
    description="""
    ## G√©n√®re un r√©sum√© automatique d'un document PDF
    
    ### üîÑ Processus :
    1. **Upload** : R√©ception du fichier PDF
    2. **Extraction** : Extraction du texte contenu dans le PDF
    3. **Analyse** : D√©coupage intelligent si le document est volumineux
    4. **R√©sum√©** : G√©n√©ration du r√©sum√© avec IA (mod√®le BART)
    5. **Nettoyage** : Suppression automatique des fichiers temporaires
    
    ### üìã Formats accept√©s :
    - **Type** : Fichiers PDF uniquement
    - **Taille** : Recommand√© < 10 MB
    - **Contenu** : Documents avec du texte extractible
    
    ### ‚ö° R√©ponses possibles :
    - **Succ√®s** : R√©sum√© du document en fran√ßais
    - **PDF vide** : Message indiquant l'absence de texte
    - **Erreur** : Message d'erreur avec d√©tails du probl√®me
    
    ### üí° Conseils :
    - Privil√©giez des PDF avec du texte s√©lectionnable
    - Les PDF scann√©s (images) ne sont pas support√©s
    - Plus le document est structur√©, meilleur sera le r√©sum√©
    """,
    response_description="R√©sum√© du document PDF au format JSON",
    tags=["üìÑ R√©sum√© PDF"],
    responses={
        200: {
            "description": "R√©sum√© g√©n√©r√© avec succ√®s",
            "content": {
                "application/json": {
                    "example": {
                        "summary": "Ce document traite de l'intelligence artificielle et de ses applications dans le domaine m√©dical. Il pr√©sente les avanc√©es r√©centes en apprentissage automatique et leurs impacts sur le diagnostic m√©dical..."
                    }
                }
            }
        },
        400: {
            "description": "Erreur dans le fichier fourni",
            "content": {
                "application/json": {
                    "example": {
                        "summary": "Aucun texte trouv√© dans le PDF."
                    }
                }
            }
        },
        500: {
            "description": "Erreur serveur lors du traitement",
            "content": {
                "application/json": {
                    "example": {
                        "summary": "Erreur lors du r√©sum√©: Probl√®me technique temporaire"
                    }
                }
            }
        }
    }
)
async def summarize_pdf(
    file: UploadFile = File(
        ...,
        description="üìé Fichier PDF √† r√©sumer",
        media_type="application/pdf"
    )
):
    # Validation du type de fichier
    if not file.filename.lower().endswith('.pdf'):
        raise HTTPException(
            status_code=400, 
            detail="Le fichier doit √™tre un PDF (.pdf)"
        )
    
    # Validation de la taille du fichier (10 MB max)
    contents = await file.read()
    if len(contents) > 10 * 1024 * 1024:  # 10 MB en bytes
        raise HTTPException(
            status_code=400,
            detail="Le fichier PDF ne doit pas d√©passer 10 MB"
        )
    
    # Cr√©er un fichier temporaire pour le PDF
    with tempfile.NamedTemporaryFile(delete=False, suffix=".pdf") as temp_file:
        temp_file.write(contents)
        temp_pdf_path = temp_file.name
    
    try:
        # Extraire le texte du PDF
        text = extract_text_from_pdf(temp_pdf_path)
        
        # V√©rifier si du texte a √©t√© extrait
        if not text.strip():
            return {"summary": "Aucun texte trouv√© dans le PDF."}
        
        # R√©sumer le texte avec gestion des textes longs
        summary = summarize_long_text(text)
        return {"summary": summary}
    
    finally:
        # Nettoyer le fichier temporaire
        if os.path.exists(temp_pdf_path):
            os.unlink(temp_pdf_path)

@app.get(
    "/",
    summary="üè† Page d'accueil de l'API",
    description="Informations g√©n√©rales sur l'API de r√©sum√© PDF",
    tags=["üìã Informations"]
)
async def root():
    """
    Point d'entr√©e principal de l'API avec informations de base.
    """
    return {
        "message": "üöÄ API de R√©sum√© PDF - Intelligence Artificielle",
        "version": "1.0.0",
        "model": "facebook/bart-large-cnn",
        "endpoints": {
            "documentation": "/docs",
            "resume_pdf": "/summarize_pdf/",
            "health": "/health"
        },
        "features": [
            "Extraction de texte PDF",
            "R√©sum√© automatique IA",
            "Gestion des longs documents",
            "Nettoyage automatique"
        ]
    }

@app.get(
    "/health",
    summary="üîç V√©rification de l'√©tat du service",
    description="Endpoint de sant√© pour v√©rifier le bon fonctionnement de l'API",
    tags=["üìã Informations"]
)
async def health_check():
    """
    V√©rification de l'√©tat de sant√© de l'API et de ses d√©pendances.
    """
    try:
        # Test simple du mod√®le
        test_summary = summarizer("This is a test.", max_length=10, min_length=5, do_sample=False)
        model_status = "‚úÖ Op√©rationnel"
    except Exception as e:
        model_status = f"‚ùå Erreur: {str(e)}"
    
    return {
        "status": "üü¢ Service en ligne",
        "timestamp": "2025-07-01T00:00:00Z",
        "model_status": model_status,
        "dependencies": {
            "FastAPI": "‚úÖ Op√©rationnel",
            "PyMuPDF": "‚úÖ Op√©rationnel", 
            "Transformers": "‚úÖ Op√©rationnel"
        }
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run("app:app", host="0.0.0.0", port=8000, reload=True)
